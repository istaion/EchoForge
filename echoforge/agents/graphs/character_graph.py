from langgraph.graph import StateGraph, END
from echoforge.agents.state.character_state import CharacterState
from echoforge.agents.nodes.perception import perceive_input, interpret_player_input_node, decide_intent_node, interpret_character_output
from echoforge.agents.nodes.rag_assessment import assess_rag_need, validate_rag_results
from echoforge.agents.nodes.rag_search import perform_rag_search
from echoforge.agents.nodes.response_generation import generate_simple_response, generate_response
from echoforge.agents.nodes.memory_update import update_character_memory, finalize_interaction
from echoforge.agents.checkpointers.postgres_checkpointer import create_safe_checkpointer, NoOpCheckpointSaver
from langsmith import traceable
from echoforge.agents.conditions.complexity_router import (
    route_by_complexity, 
    route_by_rag_need, 
    check_if_needs_new_rag
)
from echoforge.core.llm_providers import LLMManager
from echoforge.utils.config import get_config
from sqlmodel import Session, select, and_
from echoforge.db.database import get_session
from typing import Dict, Any, List, Optional
from echoforge.db.models.memory import ConversationSummary
import os

config = get_config()


def create_character_graph_with_memory(character_name: str, enable_checkpointer: bool = True) -> StateGraph:
    """
    Cr√©e le graphe principal d'un personnage avec syst√®me de m√©moire int√©gr√©.
    
    Args:
        character_name: Nom du personnage pour la persistance
        enable_checkpointer: Active ou d√©sactive le checkpointer
        
    Returns:
        StateGraph: Graphe compil√© avec ou sans checkpointer
    """
    
    # === CR√âATION DU GRAPHE ===
    graph = StateGraph(CharacterState)
    
    # === AJOUT DES N≈íUDS ===
    
    # N≈ìud d'entr√©e : perception et analyse du message
    graph.add_node("perceive", perceive_input)
    
    # Analyse des triggers :
    graph.add_node("interpret_input", interpret_player_input_node(llm_manager=LLMManager()))
    graph.add_node("decide_intent", decide_intent_node())
    
    # N≈ìuds de r√©ponse selon la complexit√©
    graph.add_node("simple_response", generate_simple_response)
    graph.add_node("assess_rag_need", assess_rag_need)
    graph.add_node("rag_search", perform_rag_search(llm_manager=LLMManager()))
    graph.add_node("validate_rag_results", validate_rag_results)
    graph.add_node("generate_response", generate_response)
    
    # N≈ìuds de finalisation avec nouveau syst√®me de m√©moire
    graph.add_node("interpret_output", interpret_character_output(llm_manager=LLMManager()))
    graph.add_node("memory_update", update_character_memory)
    graph.add_node("finalize", finalize_interaction)
    
    # === D√âFINITION DU POINT D'ENTR√âE ===
    graph.set_entry_point("interpret_input")
    
    # === D√âFINITION DES FLUX ===
    
    # Depuis la perception, routage selon la complexit√©
    graph.add_edge("interpret_input", "decide_intent")
    graph.add_edge("decide_intent", "perceive")
    graph.add_conditional_edges(
        "perceive",
        route_by_complexity,
        {
            "simple_response": "simple_response",
            "assess_rag_need": "assess_rag_need"
        }
    )
    
    # Depuis l'√©valuation RAG, routage selon le besoin
    graph.add_conditional_edges(
        "assess_rag_need", 
        route_by_rag_need,
        {
            "rag_search": "rag_search",
            "generate_response": "generate_response"
        }
    )
    
    # Depuis la recherche RAG, vers la g√©n√©ration de r√©ponse
    graph.add_edge("rag_search", "validate_rag_results")
    graph.add_conditional_edges(
        "validate_rag_results",
        check_if_needs_new_rag,
        {
            "rag_retry": "rag_search",
            "generate_response": "generate_response"
        }
    )
    
    # Depuis les r√©ponses, routage vers m√©moire ou finalisation
    graph.add_edge("simple_response", "interpret_output")
    graph.add_edge("generate_response", "interpret_output")
    graph.add_edge("interpret_output", "memory_update")
    
    # Depuis la mise √† jour m√©moire, vers la finalisation
    graph.add_edge("memory_update", "finalize")
    
    # Depuis la finalisation, fin du graphe
    graph.add_edge("finalize", END)
    
    # === COMPILATION AVEC CHECKPOINTER S√âCURIS√â ===
    try:
        # Cr√©e un checkpointer s√ªr avec fallback automatique
        checkpointer = create_safe_checkpointer(
            character_name=character_name,
            enable_checkpointer=enable_checkpointer
        )
        
        # Compile le graphe avec le checkpointer
        compiled_graph = graph.compile(checkpointer=checkpointer)
        
        # Teste la compilation
        print(f"‚úÖ Graphe compil√© avec succ√®s pour {character_name}")
        
        return compiled_graph
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors de la compilation avec checkpointer: {e}")
        print("üìù Compilation sans checkpointer comme fallback")
        
        # Fallback : compilation sans checkpointer
        return graph.compile()


class CharacterGraphManager:
    """
    Gestionnaire pour les graphes de personnages avec m√©moire persistante.
    Version am√©lior√©e avec syst√®me de fallback robuste.
    """
    
    def __init__(self, enable_checkpointer: bool = True):
        self._character_graphs = {}
        self.enable_checkpointer = enable_checkpointer
        self._fallback_mode = False
        
        # Teste la disponibilit√© du syst√®me de base de donn√©es
        self._test_database_connection()
    
    def _test_database_connection(self):
        """Teste la connexion √† la base de donn√©es."""
        try:
            with get_session() as session:
                session.exec(select(ConversationSummary).limit(1))
            print("‚úÖ Connexion √† la base de donn√©es OK")
        except Exception as e:
            print(f"‚ö†Ô∏è Probl√®me de connexion √† la base de donn√©es: {e}")
            print("üìù Mode fallback activ√© - fonctionnalit√©s limit√©es")
            self._fallback_mode = True
            self.enable_checkpointer = False
    
    def get_or_create_graph(self, character_name: str) -> StateGraph:
        """
        R√©cup√®re ou cr√©e un graphe pour un personnage donn√©.
        
        Args:
            character_name: Nom du personnage
            
        Returns:
            Graphe compil√© avec ou sans m√©moire persistante
        """
        if character_name not in self._character_graphs:
            try:
                self._character_graphs[character_name] = create_character_graph_with_memory(
                    character_name=character_name,
                    enable_checkpointer=self.enable_checkpointer and not self._fallback_mode
                )
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur cr√©ation graphe pour {character_name}: {e}")
                print("üìù Cr√©ation d'un graphe simplifi√© sans persistance")
                self._character_graphs[character_name] = self._create_simple_graph()
        
        return self._character_graphs[character_name]
    
    def _create_simple_graph(self) -> StateGraph:
        """Cr√©e un graphe simplifi√© sans persistance pour les cas d'urgence."""
        graph = StateGraph(CharacterState)
        graph.add_node("simple_process", generate_simple_response)
        graph.set_entry_point("simple_process")
        graph.add_edge("simple_process", END)
        return graph.compile()
    
    async def process_message(
        self, 
        user_message: str, 
        character_data: dict,
        thread_id: str = "default",
        session_id: Optional[str] = None
    ) -> dict:
        """
        Traite un message avec persistance automatique de la m√©moire.
        
        Args:
            user_message: Message de l'utilisateur
            character_data: Donn√©es du personnage
            thread_id: ID pour la persistance de conversation
            session_id: ID de session utilisateur
            
        Returns:
            √âtat final avec la r√©ponse g√©n√©r√©e
        """
        character_name = character_data.get("name", "unknown")
        
        # R√©cup√©ration du graphe avec m√©moire
        graph = self.get_or_create_graph(character_name)
        
        # Construction de l'√©tat initial avec informations de session
        initial_state = self._build_initial_state(
            user_message, 
            character_data, 
            thread_id, 
            session_id
        )
        
        # Configuration pour LangGraph avec thread_id
        config = {
            "configurable": {
                "thread_id": thread_id,
                "session_id": session_id,
                "character_name": character_name
            }
        }
        
        # Ex√©cution avec gestion d'erreurs robuste
        try:
            if self._fallback_mode:
                # Mode fallback : ex√©cution simple sans persistance
                result = await self._execute_simple_fallback(initial_state, config)
            else:
                # Ex√©cution normale avec persistance
                result = await graph.ainvoke(initial_state, config=config)
            
            # Ajout d'informations sur la persistance
            result["memory_info"] = {
                "thread_id": thread_id,
                "session_id": session_id,
                "character_name": character_name,
                "persistence_enabled": not self._fallback_mode,
                "checkpointer_enabled": self.enable_checkpointer
            }
            
            return result
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur traitement message avec m√©moire: {e}")
            # Fallback final
            return await self._execute_emergency_fallback(initial_state, config, str(e))
    
    async def _execute_simple_fallback(self, initial_state: CharacterState, config: dict) -> dict:
        """Ex√©cute un traitement simple sans persistance."""
        try:
            # Traitement simplifi√©
            simple_graph = self._create_simple_graph()
            result = await simple_graph.ainvoke(initial_state, config=config)
            
            # Ajout d'informations de fallback
            result["fallback_info"] = {
                "reason": "database_unavailable",
                "mode": "simple_processing"
            }
            
            return result
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur dans le fallback simple: {e}")
            return await self._execute_emergency_fallback(initial_state, config, str(e))
    
    async def _execute_emergency_fallback(self, initial_state: CharacterState, config: dict, error_msg: str) -> dict:
        """Fallback d'urgence avec r√©ponse g√©n√©r√©e localement."""
        character_name = initial_state.get("character_name", "Personnage")
        user_message = initial_state.get("user_message", "")
        
        # R√©ponse d'urgence
        emergency_response = f"Je suis {character_name}. D√©sol√©, je rencontre des difficult√©s techniques en ce moment. Pouvez-vous r√©p√©ter votre message ?"
        
        # √âtat de retour minimal
        return {
            "response": emergency_response,
            "user_message": user_message,
            "character_name": character_name,
            "emergency_fallback": True,
            "error_info": {
                "error": error_msg,
                "fallback_reason": "system_failure"
            },
            "conversation_history": initial_state.get("conversation_history", []),
            "debug_info": {
                "emergency_mode": True,
                "original_error": error_msg
            }
        }
    
    def _build_initial_state(
        self, 
        user_message: str, 
        character_data: dict, 
        thread_id: str,
        session_id: Optional[str]
    ) -> CharacterState:
        """Construit l'√©tat initial avec informations de session."""
        
        return CharacterState(
            # Input
            user_message=user_message,
            response="",
            
            # Analyse (sera remplie par le graphe)
            parsed_message=None,
            message_intent=None,
            
            # Personnage
            character_name=character_data.get("name", "unknown"),
            character_data=character_data,
            
            # Conversation avec persistance
            conversation_history=character_data.get("conversation_history", []),
            context_summary=None,
            
            # Informations de session
            thread_id=thread_id,
            session_id=session_id,
            
            # RAG
            needs_rag_search=False,
            rag_query=None,
            rag_results=[],
            relevant_knowledge=[],
            needs_rag_retry=False,
            rag_retry_reason=None,
            
            # Actions
            input_trigger_probs=None,
            activated_input_triggers=None,
            refused_input_triggers=None,
            output_trigger_probs=None,
            
            # M√©tadonn√©es
            processing_start_time=0.0,
            processing_steps=[],
            debug_info={}
        )
    
    def get_conversation_history_summary(
        self, 
        character_name: str, 
        thread_id: str,
        max_summaries: int = 5
    ) -> Dict[str, Any]:
        """
        R√©cup√®re un r√©sum√© de l'historique de conversation.
        
        Args:
            character_name: Nom du personnage
            thread_id: ID du thread
            max_summaries: Nombre maximum de r√©sum√©s √† inclure
            
        Returns:
            R√©sum√© structur√© de l'historique
        """
        if self._fallback_mode:
            return {
                "summaries": [],
                "recent_messages": [],
                "total_interactions": 0,
                "error": "Database unavailable"
            }
        
        try:
            from echoforge.agents.nodes.memory_update import EchoForgeMemoryManager
            
            llm_manager = LLMManager()
            memory_manager = EchoForgeMemoryManager(llm_manager)
            
            return memory_manager.get_conversation_context(
                character_name=character_name,
                thread_id=thread_id,
                include_summaries=True,
                max_summaries=max_summaries
            )
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration historique: {e}")
            return {
                "summaries": [],
                "recent_messages": [],
                "total_interactions": 0,
                "error": str(e)
            }
    
    def clear_conversation_memory(
        self, 
        character_name: str, 
        thread_id: str,
        keep_summaries: bool = True
    ) -> bool:
        """
        Efface la m√©moire de conversation pour un thread donn√©.
        
        Args:
            character_name: Nom du personnage
            thread_id: ID du thread
            keep_summaries: Garder les r√©sum√©s historiques
            
        Returns:
            True si succ√®s, False sinon
        """
        if self._fallback_mode:
            print("‚ö†Ô∏è Effacement m√©moire impossible - mode fallback")
            return False
        
        try:
            with get_session() as session:
                if not keep_summaries:
                    # Suppression compl√®te
                    stmt = select(ConversationSummary).where(
                        and_(
                            ConversationSummary.character_name == character_name,
                            ConversationSummary.thread_id == thread_id
                        )
                    )
                    summaries = session.exec(stmt).all()
                    for summary in summaries:
                        session.delete(summary)
                
                session.commit()
                return True
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur effacement m√©moire: {e}")
            return False
    
    def get_status(self) -> dict:
        """Retourne le statut du gestionnaire."""
        return {
            "database_available": not self._fallback_mode,
            "checkpointer_enabled": self.enable_checkpointer,
            "graphs_created": len(self._character_graphs),
            "fallback_mode": self._fallback_mode
        }
    
    def toggle_checkpointer(self, enable: bool):
        """Active/d√©sactive le checkpointer."""
        self.enable_checkpointer = enable
        # Efface les graphes existants pour qu'ils soient recr√©√©s
        self._character_graphs.clear()
        print(f"üîÑ Checkpointer {'activ√©' if enable else 'd√©sactiv√©'} - graphes recharg√©s")